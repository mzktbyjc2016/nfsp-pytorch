import LeducPoker.LeducPokerGame as LeducPoker
import LeducPoker.Policies as Policies
from LeducPoker.LeducPokerGame import PlayerActions
import numpy as np
from typing import Tuple, Iterable, List, Mapping
import copy
import itertools


def get_exploitability(policy: Policies.Policy) -> dict:
    game_values = []
    for position in [0, 1]:
        gvc = GameValueCalculator(position, policy)
        game_values.append(gvc.get_game_value())

    exploitability = sum(game_values) / 2.0
    return {"exploitability": exploitability, "p0_value": game_values[0], "p1_value": game_values[1]}


class GameValueCalculator(object):
    def __init__(self, player_num: int, opponent_policy: Policies.Policy):
        self.player_num = player_num
        self.opponent_num = (player_num + 1) % 2
        self.opponent_policy = opponent_policy

    def get_game_value(self) -> float:
        game_values = []

        for my_card, board_card in itertools.combinations(LeducPoker.LeducPokerGame.DECK, 2):
            opponent_card_probs = np.array([1/6] * 6)
            opponent_card_probs[my_card] = 0
            opponent_card_probs = self._normalize(opponent_card_probs)

            my_infoset = LeducPoker.LeducInfoset(card=my_card, bet_sequences=[(), ()], board_card=board_card)
            game_value = self._get_game_state_value(my_infoset, opponent_card_probs)
            game_values.append(game_value[self.player_num])

        return sum(game_values) / len(game_values)

    def _get_terminal_game_state_value(
            self, node: LeducPoker.LeducNode, my_card: int, opponent_card_probs: np.ndarray) -> np.ndarray:
        opponent_card_probs = opponent_card_probs.copy()
        retval = np.zeros(2)
        player_cards = [0, 0]
        player_cards[self.player_num] = my_card

        opponent_card_probs[my_card] = 0
        if node.board_card is not None:
            opponent_card_probs[node.board_card] = 0
        opponent_card_probs = self._normalize(opponent_card_probs)

        for opponent_card in LeducPoker.LeducPokerGame.DECK:
            if opponent_card == my_card or opponent_card == node.board_card:
                continue
            player_cards[self.opponent_num] = opponent_card
            payoffs = opponent_card_probs[opponent_card] * node.get_payoffs(player_cards)
            retval += payoffs
        return retval

    @staticmethod
    def _normalize(probabilities: np.ndarray) -> np.ndarray:
        return probabilities / probabilities.sum()

    def _get_opponent_game_value(
            self, my_infoset: LeducPoker.LeducInfoset, opponent_card_probs: np.ndarray) -> np.ndarray:
        cards_to_action_probs = {}
        total_action_probs = np.zeros(3)
        for opponent_card in LeducPoker.LeducPokerGame.DECK:
            if opponent_card == my_infoset.card or opponent_card == my_infoset.board_card:
                continue
            opponent_infoset = LeducPoker.LeducInfoset(
                card=opponent_card, bet_sequences=my_infoset.bet_sequences, board_card=my_infoset.board_card)
            action_probs = self.opponent_policy.action_prob(opponent_infoset)
            cards_to_action_probs[opponent_card] = action_probs
            total_action_probs += opponent_card_probs[opponent_card] * np.array(action_probs)

        retval = np.zeros(2)
        for action in PlayerActions.ALL_ACTIONS:
            if total_action_probs[action] == 0:
                continue
            post_action_card_probs = opponent_card_probs.copy()
            for opponent_card in LeducPoker.LeducPokerGame.DECK:
                if opponent_card == my_infoset.card or opponent_card == my_infoset.board_card:
                    continue
                post_action_card_probs[opponent_card] *= cards_to_action_probs[opponent_card][action]
            post_action_card_probs = self._normalize(post_action_card_probs)

            post_action_infoset = copy.deepcopy(my_infoset)
            new_round = post_action_infoset.add_action(action)
            if new_round:
                post_action_card_probs[post_action_infoset.board_card] = 0
                post_action_card_probs = self._normalize(post_action_card_probs)

            game_value = self._get_game_state_value(post_action_infoset, post_action_card_probs)
            retval += game_value * total_action_probs[action]

        return retval

    def _get_game_state_value(self, my_infoset: LeducPoker.LeducInfoset, opponent_card_probs: np.ndarray) -> np.ndarray:
        if my_infoset.is_terminal:
            return self._get_terminal_game_state_value(my_infoset, my_infoset.card, opponent_card_probs)
        elif my_infoset.player_to_act != self.player_num:
            return self._get_opponent_game_value(my_infoset, opponent_card_probs)
        else:
            state_value = np.array([float('-inf'), float('-inf')])
            best_response = None

            for action in PlayerActions.ALL_ACTIONS:
                if action == PlayerActions.FOLD and not my_infoset.can_fold:
                    continue
                elif action == PlayerActions.BET_RAISE and not my_infoset.can_raise:
                    continue

                new_infoset = copy.deepcopy(my_infoset)
                new_round = new_infoset.add_action(action)
                if new_round:
                    opponent_card_probs[new_infoset.board_card] = 0
                    opponent_card_probs = self._normalize(opponent_card_probs)

                action_value = self._get_game_state_value(new_infoset, opponent_card_probs)
                if action_value[self.player_num] > state_value[self.player_num]:
                    state_value = action_value
                    best_response = action

            best_response_probs = [0, 0, 0]
            best_response_probs[best_response] = 1
            best_response_str = "%.9f %.9f %.9f" % (
                best_response_probs[PlayerActions.BET_RAISE], best_response_probs[PlayerActions.CHECK_CALL], best_response_probs[PlayerActions.FOLD])
            print("%s %s %s %s" % (my_infoset, best_response_str, my_infoset.card, my_infoset._hidden_board_card))
            return state_value


if __name__ == "__main__":
    nash_policy = Policies.NashPolicy(
        p0_strat_filename="fullgame_strats/strat1",
        p1_strat_filename="fullgame_strats/strat2"
    )
    print("Nash: ", get_exploitability(nash_policy))  # Game values should be +- 0.0858


    print("Check/Call: ", get_exploitability(Policies.AlwaysCheckCall()))
    print("Bet/Raise: ", get_exploitability(Policies.AlwaysBet()))
