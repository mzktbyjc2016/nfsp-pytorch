import LeducPoker.LeducPokerGame as LeducPoker
import LeducPoker.Policies as Policies
from LeducPoker.LeducPokerGame import PlayerActions
import numpy as np
from typing import Tuple, Iterable, List, Mapping
import copy
import itertools


def get_exploitability(policy: Policies.Policy) -> dict:
    game_values = []
    for position in [0, 1]:
        gvc = GameValueCalculator(position, policy)
        game_values.append(gvc.get_game_value())

    exploitability = sum(game_values) / 2.0
    return {"exploitability": exploitability, "p0_value": game_values[0], "p1_value": game_values[1]}


class GameValueCalculator(object):
    def __init__(self, player_num: int, opponent_policy: Policies.Policy):
        self.player_num = player_num
        self.opponent_num = (player_num + 1) % 2
        self.opponent_policy = opponent_policy

    def get_game_value(self) -> float:
        game_values = []

        for my_card in LeducPoker.LeducPokerGame.DECK:
            opponent_card_probs = np.array([1/5] * 6)
            opponent_card_probs[my_card] = 0

            my_infoset = LeducPoker.LeducInfoset(card=my_card, bet_sequences=[(), ()], board_card=None)
            game_value = self._get_game_state_value(my_infoset, opponent_card_probs)
            game_values.append(game_value[self.player_num])

        return sum(game_values) / len(game_values)

    def _get_terminal_game_state_value(
            self, my_infoset: LeducPoker.LeducInfoset, opponent_card_probs: np.ndarray) -> np.ndarray:
        retval = np.zeros(2)
        player_cards = [0, 0]
        player_cards[self.player_num] = my_infoset.card

        for opponent_card in LeducPoker.LeducPokerGame.DECK:
            if opponent_card == my_infoset.card or opponent_card == my_infoset.board_card:
                assert opponent_card_probs[opponent_card] == 0
                continue
            player_cards[self.opponent_num] = opponent_card
            payoffs = opponent_card_probs[opponent_card] * my_infoset.get_payoffs(player_cards)
            retval += payoffs
        return retval

    @staticmethod
    def _normalize(probabilities: np.ndarray) -> np.ndarray:
        return probabilities / probabilities.sum()

    def _get_chance_game_value(
            self, my_infoset: LeducPoker.LeducInfoset, opponent_card_probs: np.ndarray) -> np.ndarray:
        retval = np.zeros(2)
        board_card_count = 0
        for board_card in LeducPoker.LeducPokerGame.DECK:
            if board_card == my_infoset.card:
                continue

            board_card_count += 1
            post_chance_opponent_card_probs = opponent_card_probs.copy()
            post_chance_opponent_card_probs[board_card] = 0
            post_chance_opponent_card_probs = self._normalize(post_chance_opponent_card_probs)

            post_chance_infoset = copy.deepcopy(my_infoset)
            post_chance_infoset.board_card = board_card

            game_state_value = self._get_game_state_value(post_chance_infoset, post_chance_opponent_card_probs)
            game_state_value *= (1.0 - opponent_card_probs[board_card]) / (len(LeducPoker.LeducPokerGame.DECK) - 2)
            retval += game_state_value

        return retval

    def _get_opponent_game_value(
            self, my_infoset: LeducPoker.LeducInfoset, opponent_card_probs: np.ndarray) -> np.ndarray:
        cards_to_action_probs = {}
        total_action_probs = np.zeros(3)
        for opponent_card in LeducPoker.LeducPokerGame.DECK:
            if opponent_card == my_infoset.card or opponent_card == my_infoset.board_card:
                assert opponent_card_probs[opponent_card] == 0
                continue
            opponent_infoset = LeducPoker.LeducInfoset(
                card=opponent_card, bet_sequences=my_infoset.bet_sequences, board_card=my_infoset.board_card)
            action_probs = self.opponent_policy.action_prob(opponent_infoset)
            cards_to_action_probs[opponent_card] = action_probs
            total_action_probs += opponent_card_probs[opponent_card] * np.array(action_probs)

        retval = np.zeros(2)
        for action in PlayerActions.ALL_ACTIONS:
            if total_action_probs[action] == 0:
                continue
            post_action_card_probs = opponent_card_probs.copy()
            for opponent_card in LeducPoker.LeducPokerGame.DECK:
                if opponent_card == my_infoset.card or opponent_card == my_infoset.board_card:
                    continue
                post_action_card_probs[opponent_card] *= cards_to_action_probs[opponent_card][action]

            post_action_card_probs = self._normalize(post_action_card_probs)

            post_action_infoset = copy.deepcopy(my_infoset)
            post_action_infoset.add_action(action)

            game_value = self._get_game_state_value(post_action_infoset, post_action_card_probs)
            retval += game_value * total_action_probs[action]

        return retval

    def _get_my_game_state_value(self, my_infoset: LeducPoker.LeducInfoset, opponent_card_probs: np.ndarray):
        state_value = np.array([float('-inf'), float('-inf')])
        best_response = None

        for action in PlayerActions.ALL_ACTIONS:
            if action == PlayerActions.FOLD and not my_infoset.can_fold:
                continue
            elif action == PlayerActions.BET_RAISE and not my_infoset.can_raise:
                continue

            new_infoset = copy.deepcopy(my_infoset)
            new_infoset.add_action(action)

            action_value = self._get_game_state_value(new_infoset, opponent_card_probs)
            if action_value[self.player_num] > state_value[self.player_num]:
                state_value = action_value
                best_response = action

        best_response_probs = [0, 0, 0]
        best_response_probs[best_response] = 1
        # best_response_str = "%.9f %.9f %.9f" % (
        #     best_response_probs[PlayerActions.BET_RAISE], best_response_probs[PlayerActions.CHECK_CALL],
        #     best_response_probs[PlayerActions.FOLD])
        #print("%s %s %s %s" % (my_infoset, best_response_str, my_infoset.card, my_infoset.board_card))
        #print("%s %s" % (my_infoset, best_response_str))
        return state_value

    def _get_game_state_value(self, my_infoset: LeducPoker.LeducInfoset, opponent_card_probs: np.ndarray) -> np.ndarray:
        if my_infoset.is_terminal:
            return self._get_terminal_game_state_value(my_infoset, opponent_card_probs)
        elif my_infoset.player_to_act == -1:  # Chance
            return self._get_chance_game_value(my_infoset, opponent_card_probs)
        elif my_infoset.player_to_act != self.player_num:
            return self._get_opponent_game_value(my_infoset, opponent_card_probs)
        else:
            return self._get_my_game_state_value(my_infoset, opponent_card_probs)

if __name__ == "__main__":
    nash_policy = Policies.NashPolicy(
        p0_strat_filename="/home/tjohnson/PycharmProjects/pyjass/strategies/leduc/0.strat",
        p1_strat_filename="/home/tjohnson/PycharmProjects/pyjass/strategies/leduc/1.strat",
        # p0_strat_filename="fullgame_strats/strat1",
        # p1_strat_filename="fullgame_strats/strat2"
    )
    import time
    _start = time.time()
    _exploitability = get_exploitability(nash_policy)
    _end = time.time()
    print("Calc time: ", _end - _start)
    print("Nash: ", _exploitability)  # Game values should be +- 0.0858


    #print("Check/Call: ", get_exploitability(Policies.AlwaysCheckCall()))
    #print("Bet/Raise: ", get_exploitability(Policies.AlwaysBet()))
